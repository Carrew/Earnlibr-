<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EarnLibr â€” Admin Send Bills </title>
<style>
/* Basic Styles for Admin Panel */
body { font-family: Arial, sans-serif; background: #0b0d17; color: #eef2f7; margin:0; padding:20px; }
h1 { background: linear-gradient(90deg, #4a90e2, #a3ff6e); -webkit-background-clip: text; color: transparent; margin-bottom:20px; }
.notif { background:#1a2235; padding:10px; border-radius:8px; margin-bottom:15px; font-size:14px; display:none; }
.notif.success { border-left:4px solid #4ade80; color:#a3ff6e; }
.notif.error { border-left:4px solid #ef4444; color:#ff8c8c; }
.provider-card { background:#0f1724; border-radius:12px; padding:15px; margin-bottom:15px; box-shadow:0 5px 15px rgba(0,0,0,0.5); transition:opacity .5s, transform .3s; position:relative; }
.provider-card:hover { transform:translateY(-4px); }
.provider-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; }
.btn { background:#4ade80; border:none; padding:6px 12px; border-radius:8px; cursor:pointer; font-weight:700; color:#041018; }
.btn.danger { background:#ef4444; color:#fff; }
.btn:disabled { opacity:0.6; cursor:not-allowed; }
.offer-breakdown { background:#1a2235; border-radius:8px; padding:10px; margin-top:10px; display:none; font-size:13px; }
.toggle-offers { margin-top:10px; background:#4a90e2; color:#041018; }
</style>
</head>
<body>

<h1>Admin Send Bills</h1>
<div id="notif" class="notif"></div>

<div class="controls">
  <button id="sendAll" class="btn">ðŸ“¤ Send All Eligible Bills</button>
</div>

<div id="providersContainer">Loading unbilled deals...</div>

<script type="module">
import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
import { auth, db } from "./firebase.js";
import { 
  collection, doc, query, where, onSnapshot, getDoc, serverTimestamp,
  runTransaction, writeBatch
} from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

const notif = document.getElementById("notif");
const providersContainer = document.getElementById("providersContainer");
const sendAllBtn = document.getElementById("sendAll");
const THRESHOLDS = { USD: 1, LRD: 300 }; // Minimum amount to send a bill
let grouped = {}; // Deals grouped by ProviderId -> OfferId
let dealsCache = {}; // Cache to hold deal data for batch updates

// --- Auth Check (Standard Admin Setup) ---
let userSession = localStorage.getItem("userSession");
if(!userSession){ window.location.href="login.html"; throw new Error("No session"); }
userSession = JSON.parse(userSession);

onAuthStateChanged(auth, async (user) => {
  if(!user || user.uid !== userSession.uid || !user.emailVerified){ 
    localStorage.removeItem("userSession"); 
    window.location.href="login.html"; 
    return;
  }
  const adminDoc = await getDoc(doc(db, "admins", user.uid));
  const data = adminDoc.exists() ? adminDoc.data() : null;
  const role = data?.role || "admin";

  if (!["admin","super_admin"].includes(role)) { 
    localStorage.removeItem("userSession"); 
    window.location.href="login.html"; 
    return;
  }

  userSession = { uid: user.uid, name: data.name || user.email, email: user.email, role: role };
  localStorage.setItem("userSession", JSON.stringify(userSession));
  loadDeals();
});

// --- Utility Functions ---
const showNotif = (msg,type="success")=>{
  notif.textContent = msg;
  notif.className = `notif ${type}`;
  notif.style.display="block";
  setTimeout(()=>{ notif.style.display="none"; },3000);
};

// UPGRADE: Use writeBatch for atomic notification sending
async function sendNotifications(uid, title, message) {
  try {
    const batch = writeBatch(db);
    batch.set(doc(collection(db, `notifications/${uid}/items`)), {
      title,
      message,
      createdAt: serverTimestamp(),
      read: false
    });
    await batch.commit();
  } catch(err) {
    console.error("Batch notification error:", err);
  }
}

// --- Load unbilled completed deals (UPGRADE: New Query Logic) ---
function loadDeals(){
  // UPGRADE: Only query deals that have been completed but are NOT YET BILLED (billedBy == null)
  const dealsQuery = query(collection(db,"completed-deals"), where("billedBy","==",null));
  
  onSnapshot(dealsQuery, snapshot=>{
    providersContainer.innerHTML="";
    grouped={};
    dealsCache={}; 

    if(snapshot.empty){ providersContainer.innerHTML="<p>No unbilled deals found.</p>"; return; }

    snapshot.forEach(docSnap=>{
      const d = docSnap.data();
      const providerId = d.providerId;
      const offerId = d.offerId;
      
      dealsCache[docSnap.id] = { ref: doc(db, "completed-deals", docSnap.id), data: d };

      if(!grouped[providerId]) grouped[providerId] = { name:d.providerName, offers:{} };

      if(!grouped[providerId].offers[offerId]){
        grouped[providerId].offers[offerId] = { 
          offerTitle:d.offerTitle, 
          currency:d.offercurrency||"USD", 
          total:0, 
          deals:[] 
        };
      }

      const offer = grouped[providerId].offers[offerId];
      offer.total += parseFloat(d.commissionEarned);
      offer.deals.push({ dealId: docSnap.id, clientName:d.clientName, commissionEarned:d.commissionEarned });
    });

    renderProviders();
  });
}

// --- Render provider cards (minor changes for new status) ---
function renderProviders(){
  providersContainer.innerHTML="";
  Object.keys(grouped).forEach(providerId=>{
    const p = grouped[providerId];
    const card = document.createElement("div");
    card.className="provider-card";

    let totalsHTML="";
    Object.values(p.offers).forEach(offer=>{
      totalsHTML+=`<div><strong>${offer.offerTitle} (${offer.currency}):</strong> ${offer.total.toFixed(2)}</div>`;
    });

    card.innerHTML=`
      <div class="provider-header">
        <h2>${p.name}</h2>
      </div>
      ${totalsHTML}
      <div></div>
      <button class="btn toggle-offers">Show Details</button>
      <div class="offer-breakdown"></div>
    `;

    const breakdown = card.querySelector(".offer-breakdown");
    Object.entries(p.offers).forEach(([offerId,offer])=>{
      const offerBox = document.createElement("div");
      offerBox.innerHTML=`<strong>${offer.offerTitle} â€” ${offer.currency} ${offer.total.toFixed(2)}</strong>`;

      offer.deals.forEach(deal=>{
        const d = document.createElement("div");
        d.textContent=`Deal ${deal.dealId} | ${deal.clientName} | +${deal.commissionEarned}`;
        offerBox.appendChild(d);
      });

      const sendBtn = document.createElement("button");
      sendBtn.className="btn";
      sendBtn.textContent="Send Bill";
      sendBtn.onclick=()=>sendBill(providerId, offerId, offer, card); 
      offerBox.appendChild(sendBtn);

      breakdown.appendChild(offerBox);
    });

    card.querySelector(".toggle-offers").onclick=()=>{ 
      breakdown.style.display = breakdown.style.display==="none"?"block":"none"; 
    };

    providersContainer.appendChild(card);
  });
}

// --- Send Single Offer Bill (FINAL, ATOMIC IMPLEMENTATION) ---
async function sendBill(providerId, offerId, offer, card = null){
  if(offer.total < (THRESHOLDS[offer.currency]||0)) {
    if(card) showNotif(`Below threshold of ${THRESHOLDS[offer.currency]} ${offer.currency}`, "error");
    return;
  }

  // Generate new Bill ID reference
  const billRef = doc(collection(db,"bills"));
  const billId = billRef.id;
  const dealIds = offer.deals.map(d=>d.dealId); // All deals in the grouped offer are unbilled

  try {
    // 1. TRANSACTION: Create Bill Documents and update Offer's financial ledger
    await runTransaction(db, async (t) => {
      
      const offerRef = doc(db, "offers_all", offerId);
      const offerSnap = await t.get(offerRef);
      if(!offerSnap.exists()) throw new Error("Offer not found.");

      // Safety check: Bill amount must be covered by outstanding balance
      if(parseFloat((offerSnap.data().outstandingBalance || 0).toFixed(2)) < parseFloat(offer.total.toFixed(2))) {
        throw new Error("Outstanding balance mismatch. Bill amount exceeds remaining outstanding balance.");
      }
      
      const billData = {
        billId,
        providerId,
        providerName: grouped[providerId].name,
        offerId,
        offerTitle: offer.offerTitle,
        currency: offer.currency,
        total: offer.total,
        deals: dealIds, 
        billedBy: userSession.uid, 
        createdAt: serverTimestamp(), 
        status:"sent",
        adminRole: userSession.role,
        paymentDate: null, 
        paymentTxnId: null, 
      };

      // Create bill records atomically
      t.set(billRef, billData);
      t.set(doc(db,`providers/${providerId}/bills/${billId}`), billData);
      
      // Update offer balance: decrease outstanding (invoiced), increase amountBilled
      t.update(offerRef, {
        amountBilled: (offerSnap.data().amountBilled || 0) + offer.total,
        outstandingBalance: (offerSnap.data().outstandingBalance || 0) - offer.total
      });

    }); // End Transaction

    // 2. BATCH: Link Deals to the Bill ID (This removes them from the loadDeals query)
    const batch = writeBatch(db);
    dealIds.forEach(dealId => {
      // Update the completed-deals document to link it to the bill
      batch.update(doc(db, "completed-deals", dealId), {
        billedBy: billId, 
        billedAt: serverTimestamp(),
      });
    });
    await batch.commit();

    // 3. Notification
    await sendNotifications(providerId, `New Bill Ready ðŸ§¾`, `Bill ${billId} for ${offer.offerTitle} totaling ${offer.total.toFixed(2)} ${offer.currency} has been generated and is ready for payment.`);

    if(card) card.remove(); // Remove card from UI
    showNotif(`Bill ${billId} sent successfully for ${offer.offerTitle}`);

  } catch(err) {
    console.error("Billing Error:", err);
    // Note: No need for status rollback here as the transaction failed before any permanent writes.
    if(card) showNotif(`Billing Failed: ${err.message}`, "error");
    else showNotif(`Billing Failed for ${offer.offerTitle}: ${err.message}`, "error");
  }
}

// --- Send All Eligible Bills (UPGRADE: Calls the atomic sendBill) ---
sendAllBtn.onclick = async ()=>{
  // Early checks for professional UX
  const providers = Object.entries(grouped);
  if(providers.length === 0){
    showNotif("No eligible bills to send.", "error");
    return;
  }

  const eligibleOffers = [];
  for(const [providerId, p] of providers){
    for(const [offerId, offer] of Object.entries(p.offers)){
      if(offer.total >= (THRESHOLDS[offer.currency] || 0)){
        eligibleOffers.push({ providerId, offerId, offer });
      }
    }
  }

  if(eligibleOffers.length === 0){
    showNotif("No offers meet the minimum threshold to send bills.", "error");
    return;
  }

  sendAllBtn.disabled=true;
  showNotif("Processing all eligible bills...", "info");

  let sentCount = 0;
  for(const { providerId, offerId, offer } of eligibleOffers){
    await sendBill(providerId, offerId, offer, null);
    sentCount++;
  }

  sendAllBtn.disabled=false;
  showNotif(`${sentCount} eligible bill(s) sent successfully!`);
};
</script>

</body>
</html>
