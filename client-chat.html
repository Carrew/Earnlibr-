<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>EarnLibr â€” Client Chat</title>

<style>
:root {
  --bg:#0b0d17;
  --card:#0f1724;
  --accent1:#4a90e2;
  --accent2:#a3ff6e;
  --muted:#94a3b8;
  --radius:14px;
}

body {
  margin:0;
  font-family:Arial,sans-serif;
  background:var(--bg);
  color:#fff;
  height:100vh;
  display:flex;
  flex-direction:column;
}

header {
  background:var(--card);
  padding:16px;
  font-size:18px;
  font-weight:700;
  text-align:center;
  border-bottom:1px solid #1a2235;
}

/* Messages area */
#messagesContainer {
  flex:1;
  padding:16px;
  overflow-y:auto;
  display:flex;
  flex-direction:column;
  gap:10px;
}

.message {
  max-width:80%;
  padding:10px 14px;
  border-radius:var(--radius);
  line-height:1.4;
  font-size:14px;
  position:relative;
}

/* Client is left (Blue), Provider is right (Green) */
.message.client {
  align-self:flex-start;
  background:rgba(74,144,226,0.2);
  color:#cfe7ff;
  border-bottom-left-radius:4px;
}
.message.provider {
  align-self:flex-end;
  background:var(--accent2);
  color:#041018;
  border-bottom-right-radius:4px;
  font-weight:500;
}
.message.system {
  align-self:center;
  max-width:90%;
  background:rgba(148,163,184,0.12);
  color:var(--muted);
  font-size:12px;
  text-align:center;
  border-radius:10px;
  padding:8px 12px;
}

.message.deleted {
  font-style:italic;
  opacity:0.6;
}

.messageTime {
  font-size:10px;
  opacity:0.7;
  margin-top:5px;
  text-align:right;
}

/* Media inside message */
.message img,
.message video {
  max-width:240px;
  border-radius:10px;
  display:block;
  margin-bottom:4px;
}

/* Action Buttons */
.controls {
  display:flex;
  gap:8px;
  margin-top:8px;
  border-top:1px solid rgba(255,255,255,0.1);
  padding-top:5px;
}
.editBtn, .delBtn {
  background:rgba(255,255,255,0.1);
  border:none;
  font-size:10px;
  padding:3px 8px;
  border-radius:4px;
  cursor:pointer;
  color:#fff;
}
.delBtn:hover {
  background:#ef4444;
}

/* Inline edit / delete UI */
.inlineEdit,
.deleteConfirm {
  margin-top:6px;
  padding-top:6px;
  border-top:1px solid rgba(255,255,255,0.16);
  display:flex;
  align-items:center;
  gap:6px;
  font-size:11px;
}

.inlineEditInput {
  flex:1;
  padding:4px 8px;
  border-radius:6px;
  border:1px solid #1e293b;
  background:#020617;
  color:#e2e8f0;
  outline:none;
  font-size:12px;
}

.inlineBtn {
  border:none;
  border-radius:6px;
  padding:3px 8px;
  font-size:11px;
  cursor:pointer;
  font-weight:600;
}

.inlineBtn.primary {
  background:var(--accent2);
  color:#041018;
}

.inlineBtn.ghost {
  background:rgba(15,23,42,0.9);
  color:#e2e8f0;
}

.inlineBtn.danger {
  background:#ef4444;
  color:#fff;
}

/* Typing indicator */
#typingIndicator {
  font-size:12px;
  color:var(--accent2);
  padding:5px 16px;
  font-style:italic;
  display:none;
}

/* Input bar */
#inputContainer {
  display:flex;
  gap:10px;
  padding:14px;
  background:var(--card);
  border-top:1px solid #1a2235;
  align-items:center;
}

#attachLabel {
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:20px;
  padding:0 4px;
}

/* hidden file input, we use label as the button */
#mediaInput {
  display:none;
}

/* Media preview (before sending) */
#mediaPreview {
  display:none;
  flex-direction:column;
  align-items:center;
  max-width:100px;
  gap:4px;
  color:var(--muted);
  font-size:12px;
}
#mediaPreview img,
#mediaPreview video {
  max-width:100px;
  border-radius:8px;
}

#messageInput {
  flex:1;
  padding:12px;
  border-radius:8px;
  border:1px solid #1a2235;
  background:#141f33;
  color:#fff;
  outline:none;
}
#sendBtn {
  padding:0 20px;
  border:none;
  border-radius:8px;
  background:var(--accent2);
  color:#041018;
  font-weight:600;
  cursor:pointer;
}

/* Toast Message */
#toast {
  position:fixed;
  bottom:20px;
  right:20px;
  background:#0f1724;
  padding:10px 14px;
  border-radius:8px;
  font-size:13px;
  display:none;
  color:#fff;
  box-shadow:0 5px 20px rgba(0,0,0,0.4);
  z-index:200;
}
</style>
</head>

<body>

<header>Secure Chat</header>

<div id="messagesContainer">
  <div id="loading">Loading chatâ€¦</div>
</div>

<div id="typingIndicator">Provider is typing...</div>

<div id="inputContainer">
  <!-- Attach button + hidden file input -->
  <label id="attachLabel" for="mediaInput">ðŸ“Ž</label>
  <input type="file" id="mediaInput" accept="image/*,video/*" />
  <div id="mediaPreview"></div>

  <input
    id="messageInput"
    placeholder="Type a messageâ€¦"
    autocomplete="off"
  />
  <button id="sendBtn">Send</button>
</div>

<div id="toast"></div>

<script type="module">
import { db } from "./firebase.js";
import {
  doc,
  getDoc,
  collection,
  onSnapshot,
  query,
  orderBy,
  serverTimestamp,
  updateDoc,
  where,
  writeBatch,
  getDocs,
  limit
} from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   URL param / chat validation
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const params = new URLSearchParams(window.location.search);
const dealId = params.get("deal");

if (!dealId) {
  document.body.innerHTML = "<p style='padding:20px;color:red;'>Invalid chat link.</p>";
  throw new Error("Missing deal ID");
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Cloudinary config
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const CLOUD_NAME = "dye3bda08";
const UPLOAD_PRESET = "earnlibrmedia";

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   DOM refs
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const messagesContainer = document.getElementById("messagesContainer");
const messageInput = document.getElementById("messageInput");
const sendBtn = document.getElementById("sendBtn");
const typingIndicator = document.getElementById("typingIndicator");
const mediaInput = document.getElementById("mediaInput");
const mediaPreview = document.getElementById("mediaPreview");
const toastEl = document.getElementById("toast");

/* Firestore refs */
const chatRef = doc(db, "chats", dealId);
const messagesRef = collection(chatRef, "messages");

let isSending = false;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Toast helper
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function showToast(msg, time = 2600) {
  toastEl.innerText = msg;
  toastEl.style.display = "block";
  clearTimeout(window.toastTimer);
  window.toastTimer = setTimeout(() => {
    toastEl.style.display = "none";
  }, time);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Cloudinary upload
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function uploadToCloudinary(file) {
  const url = `https://api.cloudinary.com/v1_1/${CLOUD_NAME}/auto/upload`;
  const formData = new FormData();
  formData.append("file", file);
  formData.append("upload_preset", UPLOAD_PRESET);

  const res = await fetch(url, { method: "POST", body: formData });
  if (!res.ok) {
    const errText = await res.text();
    throw new Error("Cloudinary upload failed: " + errText);
  }
  return await res.json(); // { secure_url, resource_type, ... }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Initial chat existence check
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const chatSnap = await getDoc(chatRef);
if (!chatSnap.exists()) {
  document.body.innerHTML = "<p style='padding:20px;color:red;'>Chat not found.</p>";
  throw new Error("Chat not found");
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Real-time messages listener
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
onSnapshot(query(messagesRef, orderBy("timestamp", "asc")), snap => {
  document.getElementById("loading")?.remove();
  messagesContainer.innerHTML = "";

  snap.forEach(docSnap => {
    const m = docSnap.data();

    const isDeleted = !!m.deleted || m.text === "[Message deleted]";

    const div = document.createElement("div");
    div.className = `message ${m.sender} ${isDeleted ? "deleted" : ""}`;

    const timeStr = m.timestamp
      ? new Date(m.timestamp.seconds * 1000).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit"
        })
      : "";

    let inner = "";

    if (isDeleted) {
      // Always show a placeholder bubble when deleted
      inner += `<div>[Message deleted]</div>`;
    } else if (m.type === "image" && m.mediaUrl) {
      inner += `<img src="${m.mediaUrl}" alt="image" />`;
      if (m.text && m.text !== "ðŸ“· Image") {
        inner += `<div>${m.text}</div>`;
      }
    } else if (m.type === "video" && m.mediaUrl) {
      inner += `
        <video controls>
          <source src="${m.mediaUrl}" type="${m.mediaMime || "video/mp4"}" />
        </video>`;
      if (m.text && m.text !== "ðŸŽ¥ Video") {
        inner += `<div>${m.text}</div>`;
      }
    } else {
      inner += `<div>${m.text || ""}</div>`;
    }

    inner += `<div class="messageTime">${timeStr}</div>`;
    div.innerHTML = inner;

    // Edit/delete controls only for client's own non-deleted messages that are still editable
    if (m.sender === "client" && m.editable && !isDeleted) {
      const controls = document.createElement("div");
      controls.className = "controls";
      controls.innerHTML = `
        <button class="editBtn">Edit</button>
        <button class="delBtn">Delete</button>
      `;

      // Inline editor instead of prompt()
      controls.querySelector(".editBtn").onclick = () => {
        // Avoid multiple editors on the same message
        if (div.querySelector(".inlineEdit")) return;

        const editWrapper = document.createElement("div");
        editWrapper.className = "inlineEdit";

        const input = document.createElement("input");
        input.className = "inlineEditInput";
        input.type = "text";
        input.value = m.text || "";

        const saveBtn = document.createElement("button");
        saveBtn.className = "inlineBtn primary";
        saveBtn.textContent = "Save";

        const cancelBtn = document.createElement("button");
        cancelBtn.className = "inlineBtn ghost";
        cancelBtn.textContent = "Cancel";

        editWrapper.appendChild(input);
        editWrapper.appendChild(saveBtn);
        editWrapper.appendChild(cancelBtn);
        div.appendChild(editWrapper);

        input.focus();
        input.select();

        const cleanup = () => {
          if (editWrapper.parentNode) {
            editWrapper.parentNode.removeChild(editWrapper);
          }
        };

        cancelBtn.onclick = cleanup;

        saveBtn.onclick = async () => {
          const newText = input.value.trim();
          if (!newText || newText === m.text) {
            cleanup();
            return;
          }
          try {
            await updateDoc(docSnap.ref, { text: newText });
            showToast("Message updated", 2200);
          } catch (err) {
            console.error(err);
            showToast("Could not update message");
          } finally {
            cleanup();
          }
        };

        // Enter to save, Escape to cancel
        input.onkeydown = e => {
          if (e.key === "Enter") {
            saveBtn.click();
          } else if (e.key === "Escape") {
            cleanup();
          }
        };
      };

      // Inline delete confirmation instead of confirm()
      controls.querySelector(".delBtn").onclick = () => {
        // Avoid stacking confirmations
        if (div.querySelector(".deleteConfirm")) return;

        const confirmRow = document.createElement("div");
        confirmRow.className = "deleteConfirm";

        const label = document.createElement("span");
        label.textContent = "Delete this message?";

        const yesBtn = document.createElement("button");
        yesBtn.className = "inlineBtn danger";
        yesBtn.textContent = "Delete";

        const noBtn = document.createElement("button");
        noBtn.className = "inlineBtn ghost";
        noBtn.textContent = "Cancel";

        confirmRow.appendChild(label);
        confirmRow.appendChild(yesBtn);
        confirmRow.appendChild(noBtn);
        div.appendChild(confirmRow);

        const cleanup = () => {
          if (confirmRow.parentNode) {
            confirmRow.parentNode.removeChild(confirmRow);
          }
        };

        noBtn.onclick = cleanup;

        yesBtn.onclick = async () => {
          try {
            await updateDoc(docSnap.ref, {
              deleted: true,
              text: "[Message deleted]",
              editable: false
            });
            showToast("Message deleted", 2200);
          } catch (err) {
            console.error(err);
            showToast("Could not delete message");
          } finally {
            cleanup();
          }
        };
      };

      div.appendChild(controls);
    }

    messagesContainer.appendChild(div);
  });

  messagesContainer.scrollTop = messagesContainer.scrollHeight;
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Provider typing listener
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
onSnapshot(chatRef, snap => {
  if (!snap.exists()) return;
  typingIndicator.style.display = snap.data().providerTyping ? "block" : "none";
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Media preview logic
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
mediaInput.addEventListener("change", () => {
  const file = mediaInput.files[0];

  if (!file) {
    mediaPreview.style.display = "none";
    mediaPreview.innerHTML = "";
    return;
  }

  mediaPreview.style.display = "flex";
  mediaPreview.innerHTML = "";

  if (file.type.startsWith("image/")) {
    const img = document.createElement("img");
    const reader = new FileReader();
    reader.onload = e => (img.src = e.target.result);
    reader.readAsDataURL(file);
    mediaPreview.appendChild(img);
  } else if (file.type.startsWith("video/")) {
    mediaPreview.innerHTML = `<span>ðŸ“¹ ${file.name}</span>`;
  }
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Send message (text + optional media)
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function sendMessage() {
  if (isSending) return;

  const text = messageInput.value.trim();
  const file = mediaInput.files[0];

  if (!text && !file) return;

  isSending = true;
  sendBtn.disabled = true;

  try {
    const batch = writeBatch(db);

    // Lock previous client message
    const lastQ = query(
      messagesRef,
      where("sender", "==", "client"),
      orderBy("timestamp", "desc"),
      limit(1)
    );
    const lastSnap = await getDocs(lastQ);
    lastSnap.forEach(d => batch.update(d.ref, { editable: false }));

    let newMsg = {
      sender: "client",
      timestamp: serverTimestamp(),
      editable: true
    };

    if (file) {
      const uploadRes = await uploadToCloudinary(file);
      const isVideo = uploadRes.resource_type === "video";

      newMsg = {
        ...newMsg,
        type: isVideo ? "video" : "image",
        mediaUrl: uploadRes.secure_url,
        mediaMime: file.type || null,
        text: text || (isVideo ? "ðŸŽ¥ Video" : "ðŸ“· Image")
      };
    } else {
      newMsg = {
        ...newMsg,
        type: "text",
        text
      };
    }

    const newDocRef = doc(messagesRef);
    batch.set(newDocRef, newMsg);

    // Update chat head
    batch.update(chatRef, {
      lastMessage: newMsg,
      clientTyping: false
    });

    await batch.commit();

    // Reset input + media preview
    messageInput.value = "";
    mediaInput.value = "";
    mediaPreview.style.display = "none";
    mediaPreview.innerHTML = "";
  } catch (err) {
    console.error("Chat send error:", err);
    showToast("Failed to send message");
  } finally {
    sendBtn.disabled = false;
    isSending = false;
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Typing indicator (clientTyping)
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
messageInput.addEventListener("input", () => {
  updateDoc(chatRef, { clientTyping: true }).catch(() => {});
  clearTimeout(window.typingTimer);
  window.typingTimer = setTimeout(() => {
    updateDoc(chatRef, { clientTyping: false }).catch(() => {});
  }, 2000);
});

sendBtn.onclick = sendMessage;
messageInput.onkeydown = e => {
  if (e.key === "Enter") sendMessage();
};
</script>
</body>
</html>
