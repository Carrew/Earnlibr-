<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>EarnLibr ‚Äî Provider Portal</title>

<style>
:root {
  --bg:#0b0d17;
  --card:#0f1724;
  --accent1:#4a90e2;
  --accent2:#a3ff6e;
  --muted:#cbd5e1;
  --radius:14px;
}
body {
  margin:0;
  font-family:Arial,sans-serif;
  background:var(--bg);
  color:#fff;
  min-height:100vh;
  display:flex;
  flex-direction:column;
}
header {
  background:var(--card);
  padding:20px;
  font-size:20px;
  font-weight:700;
  text-align:center;
  border-bottom:1px solid #1a2235;
}
#mainContainer {
  flex:1;
  display:flex;
  overflow:hidden;
  position:relative;
}

/* Sidebar */
#chatList {
  width:350px;
  border-right:1px solid #1a2235;
  overflow-y:auto;
  background:var(--card);
  display:flex;
  flex-direction:column;
}
#searchBar {
  padding:12px;
  border:none;
  border-radius:8px;
  margin:15px;
  background:#141f33;
  color:#fff;
  outline:none;
  border:1px solid #1a2235;
}
.chatItem {
  padding:15px;
  border-bottom:1px solid #0b0d17;
  cursor:pointer;
  transition:background 0.2s;
}
.chatItem:hover { background:rgba(74,144,226,0.05); }
.chatItem.active {
  background:rgba(163,255,110,0.1);
  border-left:4px solid var(--accent2);
}
.chatTitle { font-weight:600; font-size:15px; }
.chatLastMsg {
  font-size:13px;
  color:var(--muted);
  margin-top:4px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

/* Chat Window */
#chatContainer {
  flex:1;
  display:flex;
  flex-direction:column;
  background:var(--bg);
}
#chatHeader {
  display:flex;
  align-items:flex-start;
  gap:12px;
  padding:15px;
  background:var(--card);
  border-bottom:1px solid #1a2235;
}
#chatHeaderMain {
  flex:1;
  display:flex;
  flex-direction:column;
  gap:4px;
}
#backBtn {
  display:none;
  background:none;
  border:none;
  color:#fff;
  font-size:24px;
  cursor:pointer;
}
#messages {
  flex:1;
  overflow-y:auto;
  display:flex;
  flex-direction:column;
  gap:12px;
  padding:20px;
}

/* Messages */
.message {
  max-width:75%;
  padding:12px 16px;
  border-radius:18px;
  line-height:1.4;
  font-size:14px;
  position:relative;
}
.message.client {
  align-self:flex-start;
  background:rgba(74,144,226,0.15);
  border-bottom-left-radius:4px;
}
.message.provider {
  align-self:flex-end;
  background:var(--accent2);
  color:#041018;
  border-bottom-right-radius:4px;
  font-weight:500;
}
.message.system {
  align-self:center;
  font-size:12px;
  color:var(--muted);
  background:rgba(255,255,255,0.05);
  padding:8px 15px;
  border-radius:10px;
  text-align:center;
}
.message.deleted {
  font-style:italic;
  opacity:0.6;
}

.message img {
  max-width:240px;
  border-radius:10px;
  display:block;
  margin-bottom:4px;
}
.message video {
  max-width:240px;
  border-radius:10px;
  display:block;
  margin-bottom:4px;
}

.messageTime {
  font-size:10px;
  opacity:0.7;
  margin-top:5px;
  text-align:right;
}

/* Action Buttons under each provider message */
.controls {
  display:flex;
  gap:8px;
  margin-top:8px;
  border-top:1px solid rgba(0,0,0,0.1);
  padding-top:5px;
}
.editBtn, .delBtn {
  background:rgba(0,0,0,0.1);
  border:none;
  font-size:10px;
  padding:3px 8px;
  border-radius:4px;
  cursor:pointer;
  font-weight:bold;
  color:#041018;
}
.editBtn:hover { background:rgba(0,0,0,0.2); }
.delBtn:hover { background:#ef4444; color:#fff; }

/* Inline edit / delete UI */
.inlineEdit,
.deleteConfirm {
  margin-top:6px;
  padding-top:6px;
  border-top:1px solid rgba(0,0,0,0.12);
  display:flex;
  align-items:center;
  gap:6px;
  font-size:11px;
}

.inlineEditInput {
  flex:1;
  padding:4px 8px;
  border-radius:6px;
  border:1px solid #1a2235;
  background:#0b1120;
  color:#e2e8f0;
  outline:none;
  font-size:12px;
}

.inlineBtn {
  border:none;
  border-radius:6px;
  padding:3px 8px;
  font-size:11px;
  cursor:pointer;
  font-weight:600;
}

.inlineBtn.primary {
  background:var(--accent2);
  color:#041018;
}

.inlineBtn.ghost {
  background:rgba(15,23,42,0.8);
  color:#e2e8f0;
}

.inlineBtn.danger {
  background:#ef4444;
  color:#fff;
}

/* Input Area */
#typingIndicator {
  font-size:12px;
  color:var(--accent2);
  display:none;
}
#inputContainer {
  display:flex;
  gap:10px;
  padding:15px;
  background:var(--card);
  align-items:center;
}

#attachLabel {
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:20px;
  padding:0 4px;
}
#mediaInput {
  display:none;
}

/* Preview of selected media */
#mediaPreview {
  font-size:12px;
  color:var(--muted);
  max-width:120px;
  display:none;
  flex-direction:column;
  align-items:center;
  gap:4px;
}
#mediaPreview img,
#mediaPreview video {
  max-width:120px;
  border-radius:8px;
}

#messageInput {
  flex:1;
  padding:12px;
  border-radius:8px;
  border:1px solid #1a2235;
  background:#141f33;
  color:#fff;
  outline:none;
}
#sendBtn {
  padding:0 20px;
  border:none;
  border-radius:8px;
  background:var(--accent2);
  color:#041018;
  font-weight:700;
  cursor:pointer;
}

/* Toast (in-app notification) */
#toast {
  position:fixed;
  bottom:20px;
  right:20px;
  background:#0f1724;
  color:#fff;
  padding:10px 14px;
  border-radius:8px;
  font-size:13px;
  box-shadow:0 10px 25px rgba(0,0,0,0.4);
  display:none;
  z-index:100;
}

/* üîπ Deal action buttons in header */
#dealActionsBar {
  margin-top:4px;
  display:none;
  align-items:center;
  gap:8px;
  flex-wrap:wrap;
}
#dealBadge {
  font-size:11px;
  color:var(--muted);
}
.dealActionBtn {
  border:none;
  border-radius:999px;
  padding:4px 10px;
  font-size:11px;
  font-weight:600;
  cursor:pointer;
}
.dealActionBtn.completeBtn {
  background:var(--accent2);
  color:#041018;
}
.dealActionBtn.cancelBtn {
  background:#ef4444;
  color:#fff;
}

/* Inline confirm row for deal actions */
#dealConfirmRow {
  margin-top:2px;
  display:none;
  align-items:center;
  gap:8px;
  font-size:11px;
  color:var(--muted);
}

@media(max-width:768px){
  #chatContainer {
    position:fixed;
    inset:0;
    transform:translateX(100%);
    transition:transform .3s ease;
    z-index:10;
  }
  #mainContainer.chat-open #chatContainer {
    transform:translateX(0);
  }
  #backBtn { display:block; }
}
</style>
</head>

<body>
<header>EarnLibr ‚Äî Provider Portal</header>

<div id="mainContainer">
  <div id="chatList">
    <input type="text" id="searchBar" placeholder="Search clients..." />
    <div id="loading" style="padding:20px; text-align:center; color:var(--muted);">
      Loading chats...
    </div>
  </div>

  <div id="chatContainer">
    <div id="chatHeader">
      <button id="backBtn">‚Üê</button>
      <div id="chatHeaderMain">
        <div id="chatTitle" style="font-weight:700;">Select a chat</div>
        <div id="typingIndicator">Client is typing...</div>

        <!-- üîπ Deal actions for this conversation -->
        <div id="dealActionsBar">
          <span id="dealBadge"></span>
          <button id="completeDealBtn" class="dealActionBtn completeBtn">Mark Completed</button>
          <button id="cancelDealBtn" class="dealActionBtn cancelBtn">Mark Cancelled</button>
        </div>

        <!-- üîπ Inline confirm row (no browser alert) -->
        <div id="dealConfirmRow">
          <span id="dealConfirmText"></span>
          <button id="dealConfirmYes" class="inlineBtn primary">Yes</button>
          <button id="dealConfirmNo" class="inlineBtn ghost">No</button>
        </div>
      </div>
    </div>

    <div id="messages"></div>

    <div id="inputContainer">
      <!-- üìé media picker -->
      <label id="attachLabel" for="mediaInput">üìé
        <input type="file" id="mediaInput" accept="image/*,video/*" />
      </label>
      <div id="mediaPreview"></div>
      <input type="text" id="messageInput" placeholder="Type a message..." />
      <button id="sendBtn">Send</button>
    </div>
  </div>
</div>

<!-- In-app toast -->
<div id="toast"></div>

<script type="module">
import { auth, db } from "./firebase.js";
import {
  collection,
  query,
  where,
  orderBy,
  onSnapshot,
  doc,
  serverTimestamp,
  updateDoc,
  getDocs,
  writeBatch,
  limit,
  runTransaction
} from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

let currentChatId = null;
let unsubscribeMessages = null;
let providerId = null;
let allChats = [];
let isSending = false;

const mainContainer = document.getElementById("mainContainer");
const chatList = document.getElementById("chatList");
const searchBar = document.getElementById("searchBar");
const messagesContainer = document.getElementById("messages");
const messageInput = document.getElementById("messageInput");
const sendBtn = document.getElementById("sendBtn");
const backBtn = document.getElementById("backBtn");
const chatTitle = document.getElementById("chatTitle");
const typingIndicator = document.getElementById("typingIndicator");

const mediaInput = document.getElementById("mediaInput");
const mediaPreview = document.getElementById("mediaPreview");
const toast = document.getElementById("toast");

/* üîπ Deal actions UI elements */
const dealActionsBar = document.getElementById("dealActionsBar");
const dealBadge = document.getElementById("dealBadge");
const completeDealBtn = document.getElementById("completeDealBtn");
const cancelDealBtn = document.getElementById("cancelDealBtn");
const dealConfirmRow = document.getElementById("dealConfirmRow");
const dealConfirmText = document.getElementById("dealConfirmText");
const dealConfirmYes = document.getElementById("dealConfirmYes");
const dealConfirmNo = document.getElementById("dealConfirmNo");

let currentDealId = null;
let pendingDealAction = null;

/* üîπ Cloudinary config ‚Äì replace with your own */
const CLOUD_NAME = "dye3bda08";       // e.g. "your_cloud_name"
const UPLOAD_PRESET = "earnlibrmedia"; // e.g. "your_unsigned_preset"

const round = (num) => Math.round((num + Number.EPSILON) * 100) / 100;

/* Small toast helper */
function showToast(message, duration = 3000) {
  toast.textContent = message;
  toast.style.display = "block";
  clearTimeout(window.toastTimer);
  window.toastTimer = setTimeout(() => {
    toast.style.display = "none";
  }, duration);
}

async function uploadToCloudinary(file) {
  const url = `https://api.cloudinary.com/v1_1/${CLOUD_NAME}/auto/upload`;
  const formData = new FormData();
  formData.append("file", file);
  formData.append("upload_preset", UPLOAD_PRESET);

  const res = await fetch(url, { method: "POST", body: formData });
  if (!res.ok) {
    const errText = await res.text();
    throw new Error("Upload failed: " + errText);
  }
  return await res.json();
}

/* üîπ Notifications for deals (provider & promoter) */
async function sendDealNotifications(deal, title, message) {
  const batch = writeBatch(db);
  const data = { title, message, read: false, createdAt: serverTimestamp() };

  if (deal.providerId) {
    batch.set(doc(collection(db, `notifications/${deal.providerId}/items`)), data);
  }
  if (deal.promoterId && deal.promoterId !== "direct") {
    batch.set(doc(collection(db, `notifications/${deal.promoterId}/items`)), data);
  }

  await batch.commit();
}

/* üîπ Complete deal directly from chat */
async function completeDealFromChat(dealId) {
  if (!dealId) {
    showToast("No linked deal for this chat.");
    return;
  }

  let dealForNotif = null;

  try {
    await runTransaction(db, async (t) => {
      const dealRef = doc(db, "deals", dealId);
      const dealSnap = await t.get(dealRef);
      if (!dealSnap.exists()) throw new Error("Deal not found.");

      const deal = dealSnap.data();
      dealForNotif = { ...deal, id: dealId };

      if (deal.status === "processing") {
        throw new Error("Deal is already being processed.");
      }

      // Lock as processing inside transaction
      t.update(dealRef, { status: "processing" });

      const offerRef = doc(db, "offers_all", deal.offerId);
      const offerSnap = await t.get(offerRef);
      if (!offerSnap.exists()) throw new Error("Offer not found.");

      const offer = offerSnap.data();

      const platformSettingsRef = doc(db, "platform-settings", "commission");
      const platformSettingsSnap = await t.get(platformSettingsRef);
      const platformPercentage = platformSettingsSnap.exists()
        ? parseFloat(platformSettingsSnap.data().percentage)
        : 20;

      const currency = deal.offerCurrency || "USD";
      const platformRef = doc(db, `platform-earnings/${currency}`);
      const platformSnap = await t.get(platformRef);
      const platformData = platformSnap.exists()
        ? platformSnap.data()
        : { totalRevenue: 0, dealsCount: 0, dailyRevenue: {} };

      platformData.dailyRevenue = platformData.dailyRevenue || {};

      let metaSnap = null;
      if (deal.promoterId && deal.promoterId !== "direct") {
        const metaRef =
          doc(db, "promoter-earnings", deal.promoterId, "metadata", "summary");
        metaSnap = await t.get(metaRef);
      }

      const dealQuantity = deal.quantity || 1;

      let commissionEarned = 0;
      if (offer.commissionType === "percentage") {
        commissionEarned = (offer.price * dealQuantity * offer.commissionValue) / 100;
      } else if (offer.commissionType === "fixed") {
        commissionEarned = offer.commissionValue * dealQuantity;
      } else {
        commissionEarned = (deal.commissionValue || 0) * dealQuantity;
      }

      commissionEarned = round(commissionEarned);
      const platformShare = round(commissionEarned * platformPercentage / 100);
      const promoterNet = round(commissionEarned - platformShare);
      const todayUTC = new Date().toISOString().split("T")[0];

      platformData.totalRevenue = (platformData.totalRevenue || 0) + platformShare;
      platformData.dealsCount = (platformData.dealsCount || 0) + 1;
      platformData.dailyRevenue[todayUTC] =
        (platformData.dailyRevenue[todayUTC] || 0) + platformShare;

      const updatedOfferData = {
        promoSpent: round((offer.promoSpent || 0) + commissionEarned),
        amountOwed: round((offer.amountOwed || 0) + commissionEarned),
        outstandingBalance: round(
          (offer.amountOwed || 0) + commissionEarned - (offer.amountPaid || 0)
        )
      };

      let meta = metaSnap?.exists()
        ? metaSnap.data()
        : { totalLifetimeEarnings: {}, currentBalance: {}, totalWithdrawn: {} };

      if (deal.promoterId && deal.promoterId !== "direct") {
        meta.totalLifetimeEarnings[currency] =
          (meta.totalLifetimeEarnings[currency] || 0) + promoterNet;
        meta.currentBalance[currency] =
          meta.totalLifetimeEarnings[currency] - (meta.totalWithdrawn[currency] || 0);
        meta.lastUpdated = serverTimestamp();
      }

      t.update(offerRef, updatedOfferData);

      if (deal.promoterId && deal.promoterId !== "direct") {
        const promoterDealRef =
          doc(db, "promoter-earnings", deal.promoterId, "deals", dealId);
        const metaRef =
          doc(db, "promoter-earnings", deal.promoterId, "metadata", "summary");
        t.set(promoterDealRef, {
          ...deal,
          commissionAmount: promoterNet,
          fullCommission: commissionEarned,
          platformTax: platformShare,
          completedAt: serverTimestamp(),
          withdrawn: false,
          withdrawalRequestId: null
        });
        t.set(metaRef, meta, { merge: true });
      }

      t.set(platformRef, platformData, { merge: true });

      const completedRef = doc(db, "completed-deals", dealId);
      t.set(completedRef, {
        ...deal,
        status: "completed",
        completedAt: serverTimestamp(),
        completedBy: "provider",
        commissionEarned,
        platformShare,
        promoterNet,
        providerPaid: false,
        billedBy: null,
        billedAt: null
      });

      t.delete(dealRef);
    });

    if (dealForNotif) {
      await sendDealNotifications(
        dealForNotif,
        "Deal Completed ‚úÖ",
        `Deal ${dealId} marked complete.`
      );
    }

    showToast("Deal completed successfully");
    // You could also hide buttons after completion:
    // dealActionsBar.style.display = "none";
  } catch (err) {
    console.error(err);
    showToast("Error completing deal: " + err.message);
  }
}

/* üîπ Cancel deal directly from chat */
async function cancelDealFromChat(dealId) {
  if (!dealId) {
    showToast("No linked deal for this chat.");
    return;
  }

  let dealForNotif = null;

  try {
    await runTransaction(db, async (t) => {
      const dealRef = doc(db, "deals", dealId);
      const dealSnap = await t.get(dealRef);
      if (!dealSnap.exists()) throw new Error("Deal not found.");

      const deal = dealSnap.data();
      dealForNotif = { ...deal, id: dealId };

      const cancelledRef = doc(db, "cancelled-deals", dealId);

      t.set(cancelledRef, {
        ...deal,
        status: "cancelled",
        cancelledAt: serverTimestamp(),
        cancelledBy: "provider"
      });
      t.delete(dealRef);
    });

    if (dealForNotif) {
      await sendDealNotifications(
        dealForNotif,
        "Deal Cancelled ‚ùå",
        `Deal ${dealId} has been cancelled.`
      );
    }

    showToast("Deal cancelled");
    // Optionally hide buttons:
    // dealActionsBar.style.display = "none";
  } catch (err) {
    console.error(err);
    showToast("Error cancelling deal: " + err.message);
  }
}

/* üîπ Deal action confirm helpers */
function hideDealConfirm() {
  pendingDealAction = null;
  dealConfirmRow.style.display = "none";
}

function showDealConfirm(action) {
  if (!currentDealId) {
    showToast("No linked deal for this chat.");
    return;
  }
  pendingDealAction = action;
  dealConfirmText.textContent =
    action === "complete"
      ? "Mark this deal as completed?"
      : "Mark this deal as cancelled?";
  dealConfirmRow.style.display = "flex";
}

/* üîπ Wire buttons */
completeDealBtn.onclick = () => showDealConfirm("complete");
cancelDealBtn.onclick = () => showDealConfirm("cancel");

dealConfirmYes.onclick = async () => {
  const action = pendingDealAction;
  hideDealConfirm();
  if (!action || !currentDealId) return;

  if (action === "complete") {
    await completeDealFromChat(currentDealId);
  } else {
    await cancelDealFromChat(currentDealId);
  }
};

dealConfirmNo.onclick = hideDealConfirm;

/* üîπ Auth & chat logic */
auth.onAuthStateChanged(user => {
  if (!user) location.href = "login.html";
  providerId = user.uid;
  loadChats();
});

function loadChats() {
  const q = query(
    collection(db,"chats"),
    where("providerId","==",providerId),
    orderBy("lastMessage.timestamp","desc")
  );
  onSnapshot(
    q,
    snap => {
      document.getElementById("loading")?.remove();
      allChats = [];
      chatList.querySelectorAll(".chatItem").forEach(e => e.remove());

      snap.forEach(d => {
        const chat = { id:d.id, ...d.data() };
        allChats.push(chat);
        const div = document.createElement("div");
        div.className = `chatItem ${currentChatId === chat.id ? "active" : ""}`;
        div.innerHTML = `
          <div class="chatTitle">${chat.clientInfo?.name || "Client"}</div>
          <div class="chatLastMsg">${chat.lastMessage?.text || "No messages"}</div>
        `;
        div.onclick = () => openChat(chat.id);
        chatList.appendChild(div);
      });
    },
    err => {
      console.error(err);
      showToast("Failed to load chats. Please refresh.");
    }
  );
}

searchBar.addEventListener("input", e => {
  const term = e.target.value.toLowerCase();
  chatList.querySelectorAll(".chatItem").forEach(item => {
    const name = item.querySelector(".chatTitle").textContent.toLowerCase();
    item.style.display = name.includes(term) ? "block" : "none";
  });
});

function openChat(chatId) {
  currentChatId = chatId;
  mainContainer.classList.add("chat-open");

  updateDoc(doc(db,"chats",chatId), { unreadCount:0 }).catch(()=>{});

  const chat = allChats.find(c => c.id === chatId);
  chatTitle.textContent = chat?.clientInfo?.name || "Client Chat";

  // üîó get linked dealId from chat
  currentDealId = chat?.dealId || null;
  if (currentDealId) {
    dealActionsBar.style.display = "flex";
    dealBadge.textContent = `Linked deal: ${currentDealId}`;
  } else {
    dealActionsBar.style.display = "none";
    dealBadge.textContent = "";
  }
  hideDealConfirm();

  if (unsubscribeMessages) unsubscribeMessages();

  const q = query(
    collection(db,"chats",chatId,"messages"),
    orderBy("timestamp","asc")
  );

  unsubscribeMessages = onSnapshot(
    q,
    snap => {
      messagesContainer.innerHTML = "";
      snap.forEach(d => {
        const msg = d.data();

        const isDeleted = !!msg.deleted || msg.text === "[Message deleted]";

        if (msg.sender === "client" && !msg.seen) {
          updateDoc(d.ref, { seen:true }).catch(()=>{});
        }

        const div = document.createElement("div");
        div.className = `message ${msg.sender} ${isDeleted ? "deleted" : ""}`;

        const time = msg.timestamp
          ? new Date(msg.timestamp.seconds * 1000).toLocaleTimeString([], {
              hour:"2-digit",
              minute:"2-digit"
            })
          : "";

        let inner = "";

        if (isDeleted) {
          inner += `<div>[Message deleted]</div>`;
        } else if (msg.type === "image" && msg.mediaUrl) {
          inner += `<div><img src="${msg.mediaUrl}" alt="image" /></div>`;
          if (msg.text && msg.text !== "üì∑ Image") {
            inner += `<div>${msg.text}</div>`;
          }
        } else if (msg.type === "video" && msg.mediaUrl) {
          inner += `
            <video controls>
              <source src="${msg.mediaUrl}" type="${msg.mediaMime || "video/mp4"}" />
            </video>
          `;
          if (msg.text && msg.text !== "üé• Video") {
            inner += `<div>${msg.text}</div>`;
          }
        } else {
          inner += `<div>${msg.text || ""}</div>`;
        }

        inner += `<div class="messageTime">
          ${time}
          ${
            msg.sender === "provider"
              ? (msg.seen ? " ‚úì‚úì" : " ‚úì")
              : ""
          }
        </div>`;

        div.innerHTML = inner;

        // Edit/delete controls for provider's own non-deleted messages
        if (
          msg.sender === "provider" &&
          msg.editable &&
          !isDeleted
        ) {
          const controls = document.createElement("div");
          controls.className = "controls";
          controls.innerHTML = `
            <button class="editBtn">Edit</button>
            <button class="delBtn">Delete</button>
          `;

          // Inline editor instead of prompt
          controls.querySelector(".editBtn").onclick = () => {
            if (div.querySelector(".inlineEdit")) return;

            const editWrapper = document.createElement("div");
            editWrapper.className = "inlineEdit";

            const input = document.createElement("input");
            input.className = "inlineEditInput";
            input.type = "text";
            input.value = msg.text || "";

            const saveBtn = document.createElement("button");
            saveBtn.className = "inlineBtn primary";
            saveBtn.textContent = "Save";

            const cancelBtn = document.createElement("button");
            cancelBtn.className = "inlineBtn ghost";
            cancelBtn.textContent = "Cancel";

            editWrapper.appendChild(input);
            editWrapper.appendChild(saveBtn);
            editWrapper.appendChild(cancelBtn);
            div.appendChild(editWrapper);

            input.focus();
            input.select();

            const cleanup = () => {
              if (editWrapper.parentNode) {
                editWrapper.parentNode.removeChild(editWrapper);
              }
            };

            cancelBtn.onclick = cleanup;

            saveBtn.onclick = async () => {
              const newT = input.value.trim();
              if (!newT || newT === msg.text) {
                cleanup();
                return;
              }
              try {
                await updateDoc(d.ref, { text: newT });
                showToast("Message updated", 2000);
              } catch (e) {
                console.error(e);
                showToast("Could not edit message.");
              } finally {
                cleanup();
              }
            };

            input.onkeydown = e => {
              if (e.key === "Enter") {
                saveBtn.click();
              } else if (e.key === "Escape") {
                cleanup();
              }
            };
          };

          // Inline delete confirmation instead of confirm()
          controls.querySelector(".delBtn").onclick = () => {
            if (div.querySelector(".deleteConfirm")) return;

            const confirmRow = document.createElement("div");
            confirmRow.className = "deleteConfirm";

            const label = document.createElement("span");
            label.textContent = "Delete this message?";

            const yesBtn = document.createElement("button");
            yesBtn.className = "inlineBtn danger";
            yesBtn.textContent = "Delete";

            const noBtn = document.createElement("button");
            noBtn.className = "inlineBtn ghost";
            noBtn.textContent = "Cancel";

            confirmRow.appendChild(label);
            confirmRow.appendChild(yesBtn);
            confirmRow.appendChild(noBtn);
            div.appendChild(confirmRow);

            const cleanup = () => {
              if (confirmRow.parentNode) {
                confirmRow.parentNode.removeChild(confirmRow);
              }
            };

            noBtn.onclick = cleanup;

            yesBtn.onclick = async () => {
              try {
                await updateDoc(d.ref, {
                  deleted:true,
                  text:"[Message deleted]",
                  editable:false
                });
                showToast("Message deleted", 2000);
              } catch (e) {
                console.error(e);
                showToast("Could not delete message.");
              } finally {
                cleanup();
              }
            };
          };

          div.appendChild(controls);
        }

        messagesContainer.appendChild(div);
      });

      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    },
    err => {
      console.error(err);
      showToast("Failed to load messages.");
    }
  );

  onSnapshot(doc(db,"chats",chatId), s => {
    typingIndicator.style.display = s.data()?.clientTyping ? "block" : "none";
  });
}

/* Media preview when selecting file */
mediaInput.addEventListener("change", () => {
  const file = mediaInput.files[0];
  if (!file) {
    mediaPreview.style.display = "none";
    mediaPreview.innerHTML = "";
    return;
  }

  mediaPreview.style.display = "flex";
  mediaPreview.innerHTML = "";

  if (file.type.startsWith("image/")) {
    const img = document.createElement("img");
    const reader = new FileReader();
    reader.onload = e => { img.src = e.target.result; };
    reader.readAsDataURL(file);
    mediaPreview.appendChild(img);
  } else if (file.type.startsWith("video/")) {
    const span = document.createElement("span");
    span.textContent = "üìπ " + (file.name || "Video selected");
    mediaPreview.appendChild(span);
  } else {
    const span = document.createElement("span");
    span.textContent = "üìé " + (file.name || "File selected");
    mediaPreview.appendChild(span);
  }
});

/* Send message (text + optional media) */
async function sendMessage() {
  if (!currentChatId) {
    showToast("Select a chat first.");
    return;
  }
  if (isSending) return;

  const text = messageInput.value.trim();
  const file = mediaInput.files[0];

  if (!text && !file) return;

  isSending = true;
  sendBtn.disabled = true;

  const chatDoc = doc(db,"chats",currentChatId);
  const msgRef = collection(db,"chats",currentChatId,"messages");

  try {
    const batch = writeBatch(db);

    // Lock previous provider message
    const lastQ = query(
      msgRef,
      where("sender","==","provider"),
      orderBy("timestamp","desc"),
      limit(1)
    );
    const lastSnap = await getDocs(lastQ);
    lastSnap.forEach(ld => batch.update(ld.ref, { editable:false }));

    let newMsg = {
      sender:"provider",
      timestamp:serverTimestamp(),
      seen:false,
      editable:true
    };

    if (file) {
      let uploadRes;
      try {
        uploadRes = await uploadToCloudinary(file);
      } catch (err) {
        console.error(err);
        showToast("Failed to upload media. Try again.");
        throw err;
      }

      const msgType = uploadRes.resource_type === "video" ? "video" : "image";

      newMsg = {
        ...newMsg,
        type:msgType,
        mediaUrl:uploadRes.secure_url,
        mediaMime:file.type || null,
        text:text || (msgType === "video" ? "üé• Video" : "üì∑ Image")
      };
    } else {
      newMsg = {
        ...newMsg,
        type:"text",
        text
      };
    }

    const newDocRef = doc(msgRef);
    batch.set(newDocRef, newMsg);
    batch.update(chatDoc, {
      lastMessage:newMsg,
      providerTyping:false
    });

    await batch.commit();

    // Clear inputs & preview
    messageInput.value = "";
    mediaInput.value = "";
    mediaPreview.style.display = "none";
    mediaPreview.innerHTML = "";
  } catch (err) {
    console.error(err);
    showToast("Error sending message. Please try again.");
  } finally {
    isSending = false;
    sendBtn.disabled = false;
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }
}

/* Typing indicator for provider */
messageInput.oninput = () => {
  if (!currentChatId) return;
  updateDoc(doc(db,"chats",currentChatId), { providerTyping:true }).catch(()=>{});
  clearTimeout(window.t);
  window.t = setTimeout(() => {
    updateDoc(doc(db,"chats",currentChatId), { providerTyping:false }).catch(()=>{});
  }, 2000);
};

sendBtn.onclick = sendMessage;
messageInput.onkeydown = e => {
  if (e.key === "Enter") sendMessage();
};
backBtn.onclick = () => mainContainer.classList.remove("chat-open");
</script>
</body>
</html>
