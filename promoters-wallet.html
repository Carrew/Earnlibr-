<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Promoter Wallet</title>

<style>
body { font-family: Arial, sans-serif; background: #0b0d17; color: #eef2f7; margin: 0; padding: 20px; }
h1 { background: linear-gradient(90deg, #4a90e2, #a3ff6e); -webkit-background-clip: text; color: transparent; margin-bottom: 20px; }
.wallet-box { background: #0f1724; border-radius: 12px; padding: 15px; margin-bottom: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
.wallet-box h3 { margin-top: 0; }
.wallet-box p { margin: 4px 0; font-size: 14px; }
.wallet-box button { margin-top: 10px; padding: 6px 12px; border: none; border-radius: 8px; cursor: pointer; background: #4ade80; color: #041018; font-weight: 700; }
.notif { background: #1a2235; padding: 10px; border-radius: 8px; margin-bottom: 15px; font-size: 14px; display: none; }
.notif.success { border-left: 4px solid #4ade80; color: #a3ff6e; }
.notif.error { border-left: 4px solid #ef4444; color: #ff8c8c; }
</style>
</head>
<body>

<h1>Promoter Wallet</h1>
<div id="notif" class="notif"></div>
<div id="walletContainer">Loading wallet...</div>

<script type="module">
import { auth, db } from './firebase.js';
import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
import { 
  doc, getDoc, collection, query, where, getDocs, addDoc, serverTimestamp, runTransaction
} from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

const walletContainer = document.getElementById("walletContainer");
const notif = document.getElementById("notif");

/* --- Notify --- */
const showNotif = (msg, type="success") => {
  notif.textContent = msg;
  notif.className = `notif ${type}`;
  notif.style.display = "block";
  setTimeout(() => (notif.style.display = "none"), 3000);
};

/* --- Load Session & Auth (unchanged) --- */
let userSession = localStorage.getItem("userSession");
if (!userSession) {
  window.location.href = "login.html";
  throw new Error("No session found");
}
userSession = JSON.parse(userSession);

onAuthStateChanged(auth, async (user) => {
  if (!user || user.uid !== userSession.uid) {
    localStorage.removeItem("userSession");
    window.location.href = "login.html";
    return;
  }

  if (!user.emailVerified) {
    localStorage.removeItem("userSession");
    window.location.href = "login.html";
    return;
  }

  const userDocRef = doc(db, "users", user.uid);
  const userDoc = await getDoc(userDocRef);

  if (!userDoc.exists() || userDoc.data().role !== "freelancer") {
    localStorage.removeItem("userSession");
    window.location.href = "login.html";
    return;
  }

  const data = userDoc.data();
  userSession = {
    uid: user.uid,
    name: data.name,
    email: data.email,
    role: data.role,
    referralCode: data.referralCode || "",
    phone: data.phone || "",
    country: data.country || "",
    createdAt: data.createdAt || ""
  };
  localStorage.setItem("userSession", JSON.stringify(userSession));

  loadWallet(user.uid);
});

/* --- Load Wallet (unchanged) --- */
async function loadWallet(promoterId) {
  const metaRef = doc(db, "promoter-earnings", promoterId, "metadata", "summary");
  const metaSnap = await getDoc(metaRef);

  if (!metaSnap.exists()) {
    walletContainer.innerHTML = "<p>No earnings yet.</p>";
    return;
  }

  const meta = metaSnap.data();
  walletContainer.innerHTML = "";

  for (const currency in meta.currentBalance) {
    const withdrawable = meta.currentBalance[currency] || 0;
    const totalWithdrawn = meta.totalWithdrawn?.[currency] || 0;
    const totalLifetime = meta.totalLifetimeEarnings?.[currency] || 0;
    const buttonId = `withdraw-${currency}`;
    
    const box = document.createElement("div");
    box.className = "wallet-box";
    box.innerHTML = `
      <h3>${currency} Wallet</h3>
      <p>Total Lifetime Earnings: ${totalLifetime.toFixed(2)}</p>
      <p>Total Withdrawn: ${totalWithdrawn.toFixed(2)}</p>
      <p>Available to Withdraw: <strong>${withdrawable.toFixed(2)}</strong></p>
      <button id="${buttonId}">Request Withdrawal</button>
    `;
    walletContainer.appendChild(box);

    const withdrawBtn = box.querySelector(`#${buttonId}`);
    
    if (withdrawable <= 0) {
        withdrawBtn.disabled = true;
        withdrawBtn.textContent = "No Balance to Withdraw";
    }

    withdrawBtn.onclick = async () => {
      withdrawBtn.disabled = true;
      await requestWithdrawal(promoterId, currency, withdrawable, withdrawBtn);
    };
  }
}

/* --- Request Withdrawal (FINAL FIX: Updates status flag, not final withdrawn: true) --- */
async function requestWithdrawal(promoterId, currency, withdrawableAmount, btn) {
  if (withdrawableAmount <= 0) {
    btn.disabled = true;
    return showNotif("No withdrawable balance", "error");
  }
  
  const originalText = btn.textContent;
  btn.textContent = "Processing...";

  // Get a temporary ID for the request document before the transaction
  const withdrawalRequestRef = doc(collection(db, "withdrawal-requests")); 
  const withdrawalRequestId = withdrawalRequestRef.id;
  
  try {
    await runTransaction(db, async (t) => {
      // 1. READ: Get the current wallet balance summary
      const metaRef = doc(db, "promoter-earnings", promoterId, "metadata", "summary");
      const metaSnap = await t.get(metaRef);
      if (!metaSnap.exists()) throw new Error("Wallet metadata not found.");
      
      const currentBalance = metaSnap.data().currentBalance?.[currency] || 0;
      
      // 2. CHECK: Ensure the balance hasn't changed
      if (parseFloat(currentBalance.toFixed(2)) !== parseFloat(withdrawableAmount.toFixed(2))) {
        throw new Error("Balance mismatch. Please refresh and try again.");
      }
      
      // 3. READ: Find all eligible deals
      const dealsCollectionRef = collection(db, "promoter-earnings", promoterId, "deals");
      const dealsQuery = query(
        dealsCollectionRef,
        // Query deals that are NOT YET MARKED AS REQUESTED OR WITHDRAWN
        where("withdrawalRequestId", "==", null), 
        where("offerCurrency", "==", currency)
      );
      
      const dealSnap = await t.get(dealsQuery);
      if (dealSnap.empty) {
        throw new Error("No eligible deals found to link to the withdrawal.");
      }

      const dealIds = dealSnap.docs.map(d => d.id);

      // 4. WRITE: Create the withdrawal request document
      const requestData = {
        withdrawalRequestId,
        promoterId,
        currency,
        amount: withdrawableAmount,
        dealIds,
        requestedAt: serverTimestamp(),
        status: "pending" // Admin will change this to 'completed'
      };
      t.set(withdrawalRequestRef, requestData); 

      // 5. WRITE: Update the deals to link them to the request ID (marks them as 'in queue')
      // NOTE: We DO NOT set 'withdrawn: true' here. That is reserved for the Admin.
      dealSnap.docs.forEach((d) => {
        t.update(doc(dealsCollectionRef, d.id), {
          withdrawalRequestId: withdrawalRequestId,
          withdrawalRequestedAt: serverTimestamp() 
        });
      });

      // 6. WRITE: Update the promoter wallet metadata
      const newBalance = Math.max(0, currentBalance - withdrawableAmount);
      // NOTE: We DO NOT update totalWithdrawn here. That is reserved for the Admin.
      
      t.update(metaRef, {
        [`currentBalance.${currency}`]: newBalance // Atomically decrement available balance
      });
    });

    // Transaction successful
    showNotif(`Withdrawal request for ${withdrawableAmount.toFixed(2)} ${currency} submitted successfully!`);
    loadWallet(promoterId); 
    
  } catch(err) {
    console.error("Withdrawal failed:", err);
    showNotif(`Withdrawal failed: ${err.message}`, "error");
    btn.textContent = originalText;
    btn.disabled = false;
  }
}
</script>
</body>
</html>
